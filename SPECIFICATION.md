# Link Sharing Site: Technical Specification for AI Development

## 1. Introduction

This document outlines the technical specifications for building a link-sharing website. The primary features include users posting links, commenting on these links, and browsing links categorized by topics. User authentication will be simplified for this iteration.

The target technology stack is:
*   **Backend Language & Framework:** Elixir & Phoenix
*   **Frontend Interactivity:** Phoenix LiveView
*   **Database:** PostgreSQL

This specification is intended to be consumed by an AI development system to generate the application code. Precision and detail are prioritized.

## 2. Core Features

*   **Link Posting:** Authenticated (simulated) users can submit a URL, a title, and assign it to a specific topic.
*   **Commenting:** Authenticated (simulated) users can post comments on shared links.
*   **Topic-based Browsing:** Users can view links filtered by their assigned topic.
*   **Real-time Updates:** New links and comments should appear on relevant pages without requiring a manual refresh.
*   **Simplified User Handling:** Users will provide a username when posting/commenting. No formal registration or login system is required for this version.

## 3. Database Modeling (Ecto Schemas for PostgreSQL)

The database will consist of four primary tables: `users`, `topics`, `links`, and `comments`. Standard auto-incrementing integer primary keys will be used.

### 3.1. `users` Table

Stores information about users.

*   **Ecto Schema:** `MyApp.Accounts.User`
*   **Fields:**
    *   `id`: `:id`, primary key, autogenerated integer.
    *   `username`: `:string`, unique, not null. Used for display and identification.
    *   `inserted_at`: `:utc_datetime_usec`, managed by `timestamps()`.
    *   `updated_at`: `:utc_datetime_usec`, managed by `timestamps()`.
*   **Relationships:**
    *   Has many `links` (`MyApp.Content.Link`)
    *   Has many `comments` (`MyApp.Content.Comment`)
*   **Example Ecto Schema:**
    ```elixir
    defmodule MyApp.Accounts.User do
      use Ecto.Schema
      import Ecto.Changeset

      # No need to specify @primary_key or @foreign_key_type for default integer IDs
      schema "users" do
        field :username, :string
        has_many :links, MyApp.Content.Link, foreign_key: :user_id
        has_many :comments, MyApp.Content.Comment, foreign_key: :user_id
        timestamps(type: :utc_datetime_usec)
      end

      def changeset(user, attrs) do
        user
        |> cast(attrs, [:username])
        |> validate_required([:username])
        |> unique_constraint(:username)
      end
    end
    ```

### 3.2. `topics` Table

Stores categories for links.

*   **Ecto Schema:** `MyApp.Content.Topic`
*   **Fields:**
    *   `id`: `:id`, primary key, autogenerated integer.
    *   `name`: `:string`, unique, not null (e.g., "Programming", "Science").
    *   `slug`: `:string`, unique, not null (e.g., "programming", "science") for use in URLs.
    *   `description`: `:string` (optional).
    *   `inserted_at`: `:utc_datetime_usec`.
    *   `updated_at`: `:utc_datetime_usec`.
*   **Relationships:**
    *   Has many `links` (`MyApp.Content.Link`)
*   **Example Ecto Schema:**
    ```elixir
    defmodule MyApp.Content.Topic do
      use Ecto.Schema
      import Ecto.Changeset

      schema "topics" do
        field :name, :string
        field :slug, :string
        field :description, :string
        has_many :links, MyApp.Content.Link, foreign_key: :topic_id
        timestamps(type: :utc_datetime_usec)
      end

      def changeset(topic, attrs) do
        topic
        |> cast(attrs, [:name, :slug, :description])
        |> validate_required([:name, :slug])
        |> unique_constraint(:name)
        |> unique_constraint(:slug)
        # Add logic to auto-generate slug from name if not provided
      end
    end
    ```

### 3.3. `links` Table

Stores the shared links.

*   **Ecto Schema:** `MyApp.Content.Link`
*   **Fields:**
    *   `id`: `:id`, primary key, autogenerated integer.
    *   `url`: `:string` (TEXT in PG), not null.
    *   `title`: `:string`, not null.
    *   `body`: `:string` (TEXT in PG), optional (for self-posts or additional context).
    *   `user_id`: `:integer`, foreign key referencing `users.id`, not null.
    *   `topic_id`: `:integer`, foreign key referencing `topics.id`, not null.
    *   `posted_at`: `:utc_datetime_usec`, defaults to current time on creation.
    *   `score`: `:integer`, default 0 (can be used for future popularity ranking).
    *   `inserted_at`: `:utc_datetime_usec`.
    *   `updated_at`: `:utc_datetime_usec`.
*   **Relationships:**
    *   Belongs to `user` (`MyApp.Accounts.User`)
    *   Belongs to `topic` (`MyApp.Content.Topic`)
    *   Has many `comments` (`MyApp.Content.Comment`)
*   **Indexes:** `user_id`, `topic_id`, `posted_at`, `score`.
*   **Example Ecto Schema:**
    ```elixir
    defmodule MyApp.Content.Link do
      use Ecto.Schema
      import Ecto.Changeset

      schema "links" do
        field :url, :string
        field :title, :string
        field :body, :string
        field :posted_at, :utc_datetime_usec
        field :score, :integer, default: 0

        belongs_to :user, MyApp.Accounts.User, foreign_key: :user_id # type defaults to :id
        belongs_to :topic, MyApp.Content.Topic, foreign_key: :topic_id # type defaults to :id
        has_many :comments, MyApp.Content.Comment, foreign_key: :link_id

        timestamps(type: :utc_datetime_usec)
      end

      def changeset(link, attrs) do
        link
        |> cast(attrs, [:url, :title, :body, :user_id, :topic_id, :score, :posted_at])
        |> validate_required([:url, :title, :user_id, :topic_id, :posted_at])
        |> foreign_key_constraint(:user_id)
        |> foreign_key_constraint(:topic_id)
        # Add URL validation
      end
    end
    ```

### 3.4. `comments` Table

Stores comments on links.

*   **Ecto Schema:** `MyApp.Content.Comment`
*   **Fields:**
    *   `id`: `:id`, primary key, autogenerated integer.
    *   `body`: `:string` (TEXT in PG), not null.
    *   `user_id`: `:integer`, foreign key referencing `users.id`, not null.
    *   `link_id`: `:integer`, foreign key referencing `links.id`, not null.
    *   `parent_comment_id`: `:integer`, foreign key referencing `comments.id` (self-referential), nullable (for threaded comments).
    *   `posted_at`: `:utc_datetime_usec`, defaults to current time on creation.
    *   `inserted_at`: `:utc_datetime_usec`.
    *   `updated_at`: `:utc_datetime_usec`.
*   **Relationships:**
    *   Belongs to `user` (`MyApp.Accounts.User`)
    *   Belongs to `link` (`MyApp.Content.Link`)
    *   Belongs to `parent_comment` (optional, `MyApp.Content.Comment`)
    *   Has many `replies` (optional, `MyApp.Content.Comment`)
*   **Indexes:** `user_id`, `link_id`, `parent_comment_id`, `posted_at`.
*   **Example Ecto Schema:**
    ```elixir
    defmodule MyApp.Content.Comment do
      use Ecto.Schema
      import Ecto.Changeset

      schema "comments" do
        field :body, :string
        field :posted_at, :utc_datetime_usec

        belongs_to :user, MyApp.Accounts.User, foreign_key: :user_id # type defaults to :id
        belongs_to :link, MyApp.Content.Link, foreign_key: :link_id # type defaults to :id
        belongs_to :parent_comment, __MODULE__, foreign_key: :parent_comment_id # type defaults to :id
        has_many :replies, __MODULE__, foreign_key: :parent_comment_id

        timestamps(type: :utc_datetime_usec)
      end

      def changeset(comment, attrs) do
        comment
        |> cast(attrs, [:body, :user_id, :link_id, :parent_comment_id, :posted_at])
        |> validate_required([:body, :user_id, :link_id, :posted_at])
        |> foreign_key_constraint(:user_id)
        |> foreign_key_constraint(:link_id)
        |> foreign_key_constraint(:parent_comment_id)
      end
    end
    ```

## 4. Application Architecture & Domains (Phoenix Contexts)

The application logic will be organized into Phoenix Contexts.

### 4.1. `MyApp.Accounts` Context

Manages users. Due to simplified authentication, this context will primarily handle fetching or creating users based on a username.

*   **Key Functions:**
    *   `get_user(id)`: Fetches a user by ID.
    *   `get_user_by_username(username)`: Fetches a user by username.
    *   `find_or_create_user_by_username(username_attrs)`: Finds a user by username or creates a new one if not found.
        *   Input: `%{username: "string"}`
        *   Output: `{:ok, user_struct}` or `{:error, changeset}`
    *   `create_user(attrs)`: Creates a user. (Internal, called by `find_or_create_user_by_username`)

### 4.2. `MyApp.Content` Context

Manages links, topics, and comments. This is the core domain context.

*   **Topic Functions:**
    *   `list_topics()`: Returns all topics.
    *   `create_topic(attrs)`: Creates a new topic.
        *   Input: `%{name: "string", slug: "string", description: "string"}`
        *   Output: `{:ok, topic_struct}` or `{:error, changeset}`
    *   `get_topic_by_slug(slug)`: Fetches a topic by its slug.
*   **Link Functions:**
    *   `create_link(attrs)`: Creates a new link.
        *   Input: `%{url: "string", title: "string", body: "string", user_id: integer, topic_id: integer, posted_at: datetime}`
        *   Action: After successful insertion, broadcasts an event (see Section 5).
        *   Output: `{:ok, link_struct}` or `{:error, changeset}`
    *   `get_link!(id)`: Fetches a link by ID, raises if not found.
    *   `get_link_with_comments!(id)`: Fetches a link and preloads its associated user, topic, and comments (with their users).
    *   `list_links(opts \ [])`: Lists all links, paginated, sorted by `posted_at` descending. Options for pagination.
    *   `list_links_by_topic_slug(topic_slug, opts \ [])`: Lists links for a given topic slug, paginated, sorted by `posted_at` descending.
    *   `preload_associations_for_link(link_struct_or_list)`: Preloads user, topic, and comments (with users) for link(s).
*   **Comment Functions:**
    *   `create_comment(attrs)`: Creates a new comment.
        *   Input: `%{body: "string", user_id: integer, link_id: integer, parent_comment_id: integer (optional), posted_at: datetime}`
        *   Action: After successful insertion, broadcasts an event (see Section 5).
        *   Output: `{:ok, comment_struct}` or `{:error, changeset}`
    *   `list_comments_for_link(link_id)`: Lists all comments for a specific link, preloading users, sorted by `posted_at` ascending. For threaded comments, this would need to handle fetching in hierarchical order or allow client-side structuring.

## 5. Real-time Features (Phoenix Channels & PubSub)

Phoenix Channels and PubSub will be used for real-time updates to clients (LiveViews).

### 5.1. PubSub Topics

*   **Global Link Updates:**
    *   Topic: `"links:new"`
    *   Purpose: Notifies clients (e.g., homepage LiveView) about newly created links.
    *   Broadcast by: `MyApp.Content.create_link/1` upon successful link creation.
*   **Comment Updates (Per Link):**
    *   Topic: `"comments:<link_id>:new"` (e.g., `"comments:123:new"`)
    *   Purpose: Notifies clients viewing a specific link about new comments on that link.
    *   Broadcast by: `MyApp.Content.create_comment/1` upon successful comment creation.

### 5.2. Event-Based Modeling & Payloads

*   **Event: New Link Created**
    *   Trigger: `MyApp.Content.create_link/1` successfully inserts a link.
    *   Action: `MyAppWeb.Endpoint.broadcast("links:new", "new_link", payload)`
    *   Payload: A map containing essential link data, preloaded with user and topic information.
        ```elixir
        %{
          id: link.id,
          url: link.url,
          title: link.title,
          body: link.body,
          posted_at: link.posted_at,
          score: link.score,
          user: %{id: user.id, username: user.username},
          topic: %{id: topic.id, name: topic.name, slug: topic.slug},
          comment_count: 0 # Initially 0
        }
        ```
*   **Event: New Comment Created**
    *   Trigger: `MyApp.Content.create_comment/1` successfully inserts a comment.
    *   Action: `MyAppWeb.Endpoint.broadcast("comments:#{link_id}:new", "new_comment", payload)`
    *   Payload: A map containing essential comment data, preloaded with user information.
        ```elixir
        %{
          id: comment.id,
          body: comment.body,
          posted_at: comment.posted_at,
          link_id: comment.link_id,
          parent_comment_id: comment.parent_comment_id, # nil if not a reply
          user: %{id: user.id, username: user.username}
        }
        ```

### 5.3. LiveView Integration

*   **`MyAppWeb.LinkListLive` (Homepage / All Links):**
    *   `mount/3`:
        *   Fetches initial list of links via `MyApp.Content.list_links/1` (potentially from cache, see Section 6).
        *   Subscribes to `"links:new"` topic: `MyAppWeb.Endpoint.subscribe("links:new")`.
    *   `handle_info({"new_link", link_payload}, socket)`:
        *   Receives the `link_payload`.
        *   Prepends the new link to the `socket.assigns.links` list.
        *   Updates the LiveView, causing re-render with the new link at the top.
*   **`MyAppWeb.TopicLinkListLive` (Links by Topic):**
    *   `mount/3`:
        *   Fetches initial list of links for the specific topic via `MyApp.Content.list_links_by_topic_slug/2`.
        *   Subscribes to `"links:new"` topic.
    *   `handle_info({"new_link", link_payload}, socket)`:
        *   If `link_payload.topic.slug` matches the current LiveView's topic slug, prepend the new link.
*   **`MyAppWeb.LinkDetailLive` (Individual Link Page):**
    *   `mount/3`:
        *   Fetches the link and its comments via `MyApp.Content.get_link_with_comments!/1`.
        *   Subscribes to `"comments:<link_id>:new"` topic using the current link's ID.
    *   `handle_info({"new_comment", comment_payload}, socket)`:
        *   Receives the `comment_payload`.
        *   Appends the new comment to the `socket.assigns.comments` list (or handles nesting if implemented).
        *   Updates the LiveView, causing re-render with the new comment.

## 6. Caching Strategy

To improve performance for frequently accessed link listings (e.g., the homepage).

### 6.1. Target

The primary link listing page (e.g., served by `MyAppWeb.LinkListLive`).

### 6.2. Mechanism

*   Use **Erlang Term Storage (ETS)** managed by a dedicated **GenServer** process for in-memory caching.
*   Define a cache GenServer module, e.g., `MyApp.Cache`. This GenServer will:
    *   Initialize an ETS table on startup (e.g., `:named_table`, `public`, `read_concurrency: true`).
    *   Provide an API for getting, putting, and deleting cache entries (e.g., `get_homepage_links/0`, `put_homepage_links/1`, `delete_homepage_links/0`).
    *   Handle cache expiry internally (e.g., by storing timestamps with entries or using a periodic cleanup task).
*   Add this `MyApp.Cache` GenServer to the application's supervision tree.

### 6.3. Implementation in `MyApp.Content`

Modify/create a function like `Content.list_homepage_links/0`:

```elixir
defmodule MyApp.Content do
  # ... other functions ...

  alias MyApp.Cache # Assumes a GenServer MyApp.Cache exists

  def list_homepage_links() do
    case Cache.get_homepage_links() do # Call the GenServer API
      nil ->
        # Cache miss
        links =
          list_links() # Fetch potentially all links
          |> preload_associations_for_links() # Preload necessary data
          |> Enum.take(25) # Example: Take top 25 for homepage

        # Store the processed data in the cache via the GenServer
        Cache.put_homepage_links(links) # TTL logic handled within Cache GenServer

        links # Return fresh data

      cached_links ->
        # Cache hit
        cached_links
    end
  end

  # Helper to preload necessary data for links (user, topic, comment count)
  # (Ensure this helper is efficient and selects only needed fields)
  def preload_associations_for_links(links) do
    # ... (implementation as before, ensuring Repo is aliased) ...
    Repo.preload(links, [:user, :topic, comments: :user]) # Adjust preloads as needed
    |> Enum.map(fn link ->
      Map.merge(link, %{
        comment_count: Enum.count(link.comments),
        user: Map.take(link.user, [:id, :username]),
        topic: Map.take(link.topic, [:id, :name, :slug])
      })
      |> Map.drop([:comments]) # Don't send all comments for list view if not needed
    end)
  end


  # Ensure create_link clears/updates this cache
  def create_link(attrs) do
    # Assuming attrs now contains integer IDs or they are looked up
    # ... (user lookup, changeset validation for integer foreign keys) ...

    # Example assuming user_id and topic_id are integers in attrs
    changeset = Link.changeset(%Link{posted_at: DateTime.utc_now()}, attrs)

    Multi.new()
    |> Multi.insert(:link, changeset)
    # Preloading user/topic might happen after the transaction or based on IDs in attrs
    |> Multi.run(:user, fn _repo, %{link: link_struct} -> Accounts.get_user(link_struct.user_id) end)
    |> Multi.run(:topic, fn _repo, %{link: link_struct} -> get_topic(link_struct.topic_id) end) # Assuming get_topic
    |> Repo.transaction()
    |> case do
      {:ok, %{link: link, user: user, topic: topic}} ->
        # Invalidate cache via GenServer
        Cache.delete_homepage_links()

        # Broadcast event (payload now uses integer IDs)
        link_payload = %{
          id: link.id, url: link.url, title: link.title, body: link.body,
          posted_at: link.posted_at, score: link.score,
          user: %{id: user.id, username: user.username},
          topic: %{id: topic.id, name: topic.name, slug: topic.slug},
          comment_count: 0
        }
        MyAppWeb.Endpoint.broadcast("links:new", "new_link", link_payload)

        {:ok, link}
      {:error, _failed_operation, failed_value, _changes_so_far} ->
        {:error, failed_value} # This could be a changeset
    end
  end
end
```

### 6.4. Cache Invalidation

*   **Primary Method: TTL (Time-To-Live):** The `MyApp.Cache` GenServer should manage the lifetime of entries in the ETS table. It can store insertion timestamps alongside the data and refuse to return stale data, or periodically scan the table to remove expired entries.
*   **Secondary Method (Event-Driven):** Upon successful creation of a new link (in `Content.create_link/1`), explicitly delete the cache entry by calling the appropriate function on the `MyApp.Cache` GenServer (e.g., `MyApp.Cache.delete_homepage_links()`). This ensures the next request fetches fresh data and repopulates the cache. This is shown in the example `create_link` function.

## 7. Simplified User Handling

*   **No Authentication System:** No login, registration, or password management.
*   **Username Input:**
    *   When submitting a link or a comment, the LiveView form will include a text input for "Username".
    *   This username is passed to the relevant context function (`Content.create_link` or `Content.create_comment`).
*   **User Creation/Retrieval:**
    *   The context function will call `MyApp.Accounts.find_or_create_user_by_username(%{username: provided_username})`.
    *   This function attempts to find an existing user with that username. If not found, it creates a new user record.
    *   The `user_id` from the found/created user is then associated with the new link or comment.

## 8. Flow Diagrams (Textual Descriptions)

### 8.1. Link Submission Flow

1.  **User Action:** Navigates to the "Submit New Link" page (e.g., `/links/new`).
    *   Served by: `MyAppWeb.LinkSubmitLive`.
2.  **LiveView `mount/3` (`LinkSubmitLive`):**
    *   Initializes an empty changeset for the link form.
    *   Fetches list of topics (`MyApp.Content.list_topics/0`) for a dropdown selector.
    *   Assigns changeset and topics to the socket.
3.  **User Action:** Fills in the link submission form (URL, Title, Body (optional), selects Topic, enters Username).
    *   LiveView provides client-side validation feedback via `handle_event("validate", ...)` if implemented.
4.  **User Action:** Clicks "Submit".
    *   Triggers `handle_event("save", %{"link" => link_params, "username" => username}, socket)` in `LinkSubmitLive`.
5.  **LiveView `handle_event("save", ...)`:**
    a.  Calls `MyApp.Accounts.find_or_create_user_by_username(%{username: username})` to get/create the user.
        *   If error, display error to user.
    b.  If user OK, merges `user_id` and `posted_at: DateTime.utc_now()` into `link_params`.
    c.  Calls `MyApp.Content.create_link(processed_link_params)`.
6.  **`MyApp.Content.create_link/1`:**
    a.  Validates parameters and creates an Ecto changeset.
    b.  If valid:
        i.  Inserts the link into the database.
        ii. Preloads user and topic for the payload.
        iii.Broadcasts the `"links:new"` event with the link payload (see Section 5.2) via `MyAppWeb.Endpoint`.
        iv. Invalidates/clears the homepage links cache (see Section 6.4).
        v.  Returns `{:ok, link_struct}`.
    c.  If invalid: Returns `{:error, changeset}`.
7.  **LiveView `handle_event("save", ...)` (Continued):**
    a.  If `Content.create_link` returns `{:ok, link}`:
        *   Sets a flash message for success.
        *   Redirects user to the newly created link's detail page (`/links/#{link.id}`) or the homepage.
    b.  If `{:error, changeset}`:
        *   Assigns the error changeset to the socket to display errors on the form.

### 8.2. Link Viewing & Real-time Update Flow (Homepage)

1.  **User Action:** Navigates to the homepage (`/`).
    *   Served by `MyAppWeb.LinkListLive`.
2.  **LiveView `mount/3` (`LinkListLive`):**
    a.  Calls `MyApp.Content.list_homepage_links()` (which uses caching) to get the initial list of links.
    b.  Assigns the list of links to `socket.assigns.links`.
    c.  Subscribes to PubSub topic: `MyAppWeb.Endpoint.subscribe("links:new")`.
3.  **LiveView Renders:** Displays the list of links.
4.  **(Elsewhere) New Link Submitted:** Another user submits a new link, triggering the `Content.create_link/1` flow, which broadcasts `"links:new"`.
5.  **LiveView `handle_info({"new_link", link_payload}, socket)` (`LinkListLive`):**
    a.  Receives the broadcasted `link_payload`.
    b.  Prepends the new link data (from `link_payload`) to the `socket.assigns.links` list.
    c.  Phoenix LiveView automatically detects the change in assigns and re-renders the component, displaying the new link at the top of the list without a page reload.

### 8.3. Commenting Flow

1.  **User Action:** Navigates to a specific link's detail page (e.g., `/links/<link_id>`).
    *   Served by `MyAppWeb.LinkDetailLive`.
2.  **LiveView `mount/3` (`LinkDetailLive`):**
    a.  Extracts `link_id` from params.
    b.  Calls `MyApp.Content.get_link_with_comments!(link_id)` to fetch the link and its associated comments (preloading users for link and comments).
    c.  Assigns link and comments to the socket.
    d.  Initializes an empty changeset for the new comment form.
    e.  Subscribes to PubSub topic: `MyAppWeb.Endpoint.subscribe("comments:#{link_id}:new")`.
3.  **LiveView Renders:** Displays the link details and its current comments, along with a form to add a new comment.
4.  **User Action:** Fills in the comment form (Body, Username) and clicks "Post Comment".
    *   Triggers `handle_event("save_comment", %{"comment" => comment_params, "username" => username}, socket)` in `LinkDetailLive`.
5.  **LiveView `handle_event("save_comment", ...)`:**
    a.  Calls `MyApp.Accounts.find_or_create_user_by_username(%{username: username})`.
    b.  If user OK, merges `user_id`, `link_id` (from `socket.assigns.link.id`), and `posted_at: DateTime.utc_now()` into `comment_params`.
    c.  Calls `MyApp.Content.create_comment(processed_comment_params)`.
6.  **`MyApp.Content.create_comment/1`:**
    a.  Validates parameters.
    b.  If valid:
        i.  Inserts the comment into the database.
        ii. Preloads user for the payload.
        iii.Broadcasts the `"comments:<link_id>:new"` event with the comment payload (see Section 5.2).
        iv. Returns `{:ok, comment_struct}`.
    c.  If invalid: Returns `{:error, changeset}`.
7.  **LiveView `handle_event("save_comment", ...)` (Continued):**
    a.  If `Content.create_comment` returns `{:ok, comment}`:
        *   Resets the comment form (clears the changeset).
        *   (No redirect needed, new comment will appear via PubSub).
    b.  If `{:error, changeset}`:
        *   Assigns the error changeset to the socket to display errors on the comment form.
8.  **LiveView `handle_info({"new_comment", comment_payload}, socket)` (`LinkDetailLive`):**
    a.  Receives the broadcasted `comment_payload`.
    b.  Appends the new comment data to `socket.assigns.comments`.
    c.  LiveView re-renders, showing the new comment in the list.

## 9. UI/UX Considerations (Brief)

*   **Clear Navigation:** Easy access to homepage, submit link page, and topic listings.
*   **Informative Displays:** Links should show title, URL (domain), submitter, time, topic, and comment count.
*   **User Feedback:** Clear messages for successful submissions, errors, and loading states.
*   **Forms:** Standard forms for link and comment submission with appropriate validation.

## 10. Project Setup (Assumed)

*   A new Phoenix project generated with `mix phx.new my_app --live --ecto`. (Replace `my_app` with actual project name, e.g., `reddit`)
*   PostgreSQL database configured.
*   No external cache dependency like Nebulex needed; use built-in ETS/GenServer.

This specification provides a detailed blueprint. The AI should implement the Ecto schemas, context modules, LiveViews, PubSub logic, and the ETS-based Cache GenServer as described. 